Group_28
10.05.2022
Postman_tests

КОНСПЕКТ ПО ВИДЕОУРОКУ


*****1*****

   ТОКЕН
   Когда пользователь на сервере залогинился, и все его следующие запросы должны быть с этим токеном. Токен показывает что пользователь залогинен. Таким образом сервер видит, что пользователю можно доверять и отдать данные.

    Создаем запрос Login
POST
http://162.55.220.72:5005/login
В body => form-data прописываем ключи, которые ожидаются кодом бэкэнда на входе (код PyCharm см. ниже):
login Alexey
password 3432243

Response:
{
    "token": "/s34lfgbj/Alexey/jjd909/56381kjkWpqc2526343224315000evny"
}

   На сервере код PyCharm выглядит так:
===============================
@app.route('/login', methods=['GET', 'POST'])
def test_login():
    
    if request.method == 'POST':
        login = request.form.get('login')
        password = request.form.get('password')

        t_token - str('/s34lfqbj/' + str(login) + '/jjd909/' + str и т.д.

        result = {'token': t_token}
        login_list[str(login)] = t_token

        return jsonify(result)
===============================

*****1*****



*****2***** 

   ПУНКТ РУЧНОГО ПЕРЕМЕЩЕНИЯ ТОКЕНА
   Пока сделаем вручную.
   Суть данной задачи такова - нам нужно этот токен надо автоматически забрать и передать в следующий запрос.

   Смотрим запрос в PyCharm, который у нас требует токен:
================================
@app.route('/test_pet_info', methods=['GET', 'POST'])
def test_pet_info();

    if request.method == 'POST':


        au_token = request.form.get('auth_token')
        ch_token = check_token(au_token)

        if ch_token:
            age = int(request.form.get('age'))
            weight = int(request.form.get('weight'))
            name = request.form.get('name')

            result = {'name': name,
                         'age': age,
                         'daily_food':weight * 0.012,
                         'daily_sleep': weight * 2.5}
            # logging.info('User request to /test_pet_info', 'name = ', name, 'age = ', age, 'weight = ', weight)
            return jsonify(result)

         else:
             return jsonify("Invalid token. Sign in please")
================================
   По данному коду видно эндпоинт /test_pet_info
Код запроса на входе ожидает:
age
weight
name

   Создаем реквест /test_pet_info
POST
http://162.55.220.72:5005/test_pet_info
Body, form-data:
name Rex
age 3
weight 8

   Если к этим трем параметрам не добавить строку с токеном, то получим ошибку 500 (Ошибка сервера).
Поэтому, в form-data добавляем строку с токеном: 
Заглядываем в код запроса, где имя ключа строки токена:
auth_token 
Вместо значения встявляем предыдущий токен:
"/s34lfgbj/Alexey/jjd909/56381kjkWpqc2526343224315000evny"

т.е.
name Rex
age 3
weight 8
auth_token "/s34lfgbj/Alexey/jjd909/56381kjkWpqc2526343224315000evny"

   Сервер должен вернуть результат:
{
    "age": 3,
    "daily_food": 0.096,
    "daily_sleep": 20.0,
    "name": "Rex"
}

   Если токен ввести с ошибкой в имени пользователя (например вместо Alexey ввести Alexe), то сервер вернет текст ошибки:
"Invalid token. Sign in please"

   Вот таким образом мы пальцами передали токен.

Коротко о том, какие действия произошли от начала логина и запроса на получение данных:
1)
   Пользователь залогинился: 
POST 
http://162.55.220.72:5005/login
login Alexey
password 3432243
и получил в ответе от сервера токен:
"/s34lfgbj/Alexey/jjd909/56381kjkWpqc2526343224315000evny"
2)
   Далее пользователь отправил запрос на получение рекомендаций по количеству еды и сна по своему питомцу, заполнив поля его имени, возраста и веса. Но невидимое пользователю поле токена auth_token должно заполнятся автоматически из окружения, после того как пользователь уже залогинился:
POST 
http://162.55.220.72:5005/test_pet_info
name Rex
age 3
weight 8
auth_token "/s34lfgbj/Alexey/jjd909/56381kjkWpqc2526343224315000evny"

18:00 остановился

****2**** 



****3****
 
   АВТОМАТИЧЕСКИЙ ЗАБОР ТОКЕНА И ПЕРЕДАЧА В СЛЕДУЮЩИЙ ЗАПРОС
   Теперь этот токен нужно автоматически забрать и передать в следующий запрос.
   Соответственно, код забора токена и передачи его в окружение, должен быть написан в запросе, где пользователь логинится, в окне Tests. 
  
   ОКРУЖЕНИЕ.
   Далее поработаем с коружением и посмотрим как это все делать скриптами.
   Окружение - это такая область памяти, в которую мы можем класть значение и из которой можем эти значения доставать. Эта область вполне настраиваемая.

   СОЗДАНИЕ ПЕРЕМЕННОЙ В ОКРУЖЕНИИ
   Слева в колонке меню Postman заходим в Environments.
Жмем слева сверху, в строке My Workspace, кнопку New, выбираем Environments. 
Называем новое окружение - Environment_group_28
В новом коружении создаем переменную с именем - token (колонка VARIABLE).
Кологку TYPE оставляем default
Остальные колонки пока оставляем пустым.
Обязательно жмем сохранить.

   НАЗНАЧЕНИЕ ОКРУЖЕНИЯ В КОЛЛЕКЦИЮ
   Заходим во вкладку Collections.
В верхнем правом углу возле иконки "глаз" во всплывающем меню выбираем нужное окружение - Environment_group_28.
Теперь данная коллекция будет работать с этим окружением.
Чтобы посмотреть что есть в окружении, жмем иконку "глаз" возле имени окружения.
На данный момент можно увидеть только пустую переменную "token".
В Globals (глобальном окружении) пока ничего нет.
Пока открыто окно просмотра переменных окружения, можно нажать Edit для редактирования переменной.
Чтобы закрыть редактирование переменной окружения надо просто нажать крестик во вкладке окна, рядом со вкладками запросов.

   ИСПОЛЬЗОВАНИЕ СНИППЕТОВ В КАЧЕСТВЕ ШАБЛОНОВ ДЛЯ СКРИПТА
   Переходим в запрос Login
Открываем вклаку Tests
Ставим курсор на 5 строку.
   Справа под кнопкой Cookies, жмем на стрелочку бокового всплывающего окна.
Выбираем СНИППЕТ: 
Set an environment variable
В окне Tests появится код:
========================
pm.environment.set("variable_key", "variable_value");
========================
Это тот кусочек теста, который перенесет токен в наше окружение.

   Вместо "variable_key" введем "token" (кавычки обязательно).

   А вместо "variable_value" введем другое значение:
Ставим курсор на 1 строку.
Выбираем СНИППЕТ:
Response body: JSON value check
   Во окне Tests появится код:
========================
pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.value).to.eql(100);
});
========================

   Из этого текста кода нам нужно взять только:
========================
var jsonData = pm.response.json();
========================
Остальную часть кода стираем.
   
   Ставим курсор на 1 строку.
Вставляем скопированную строку:
========================
var jsonData = pm.response.json();
========================

   Изменяем слово var на let:
========================
let jsonData = pm.response.json();
========================

   Ставим курсор на 2 строку и пишем:
========================
let token = jsonData.token;
========================

   Теперь, копируем слово token со 2 строки нашего кода и вставляем в 5 строку вместо "variable_value", получится:
========================
pm.environment.set("token", token);
========================

   ПОЛУЧИЛСЯ КУСОЧЕК СКРИПТА: 
========================
let jsonData = pm.response.json();
let token = jsonData.token;


pm.environment.set("token", token);
========================
который отработает, засунет значение в заранее созданную переменную token в окружение Environment_group_28, которое выбрано на данный момент в Postman:

   Сохраняем и жмем Send.
Заходим в просмотр переменных в окружении через иконку "глаз", где мы увидим что в столбике CURRENT VALUE появилась строка с токеном:
/s34lfgbj/Alexey/jjd909/99592kjkWpqc24963432243293077evny

   ВНОСИМ СКРИПТ В КЛЮЧ auth_token В ЗАПРОСЕ test_pet_info.
Теперь заходим в запрос test_pet_info
VALUE ключа auth_token, меняем на:
{{token}}
т.е. стираем ранее введенный вручную токен, и, открыв фигурную скобку { в строке VALUE, выбираем во всплывающем окне одну из предложенных переменных, тем самым имя переменной автоматически занесется в двойные фигурные скобки:
{{token}}
После чего нужно сохранить запрос.

   Отправляем запрос, получим ответ:
========================
{
    "age": 3,
    "daily_food": 0.096,
    "daily_sleep": 20.0,
    "name": "Rex"
}
========================

   КОРОТКАЯ ЛОГИКА ОТРАБОТКИ СКРИПТА ПО ПОДТЯГИВАНИЮ ТОКЕНА В ОКРУЖЕНИЕ
Линейная логика отработки подтягивания и заливания токена в окружение, откуда оно притягивается при последкющих запросах:
1) Пользователь залогинился /login ;
2) Сервер вернул ответ с токеном;
3) Скрипт запроса /login подтянул токен в окружение;
4) Пользователь отправляет запрос по данным своего питомца /test_pet_info ;
5) В запросе /test_pet_info значение переменной токена auth_token автоматически берется с окружения;
6) Сервер в запросе /test_pet_info видит токен, после чего разрешает передачу пользователю запрошенные данные.

   ИТОГИ ДАННОЙ ЧАСТИ ОБЩЕЙ ТЕМЫ С ВИДЕОУРОКА
- Т.е. мы можем опять отправить запрос POST /login (залогинились), 
- новый токен получили, 
- он автоматом засунулся в окружение, 
- запрос POST /test_pet_info который требует токен для отработки, получает токен из окружения и отрабатывает. 
- Нам не надо пальцами при каждом логине переставлять токен.

КОНЕЦ КОНСПЕКТА ПО ВИДЕОУРОКУ 14:30-22:16.

*****3*****




*****4*****
   
   НОВЫЕ ПЕРЕМЕННЫЕ В ОКРУЖЕНИИ: url и port
   В окружении Environment_group_28 сделать два переменных:
url (CURRENT: http://162.55.220.72)
port (CURRENT: 5005)
TYPE и INITIAL VALUE оставляем пустыми.
Сохранить.

   В коллекции group_28, выбрать окружение Environment_group_28, в запросе test_pet_info в строке адреса
http://162.55.220.72:5005/test_pet_info
где текст url
http://162.55.220.72
и порта
5005 
меняем на переменныt в окружении, открывая двойные фигурные скобки {{}} :
{{url}}:{{port}}/test_pet_info
Сохранить. Отправить запрос.
Сервер должен вернуть ответ:
========================
{
    "age": 3,
    "daily_food": 0.096,
    "daily_sleep": 20.0,
    "name": "Rex"
}
========================

*****4*****




*****5*****

   CОЗДАТЬ НОВЫЙ РЕКВЕСТ
   Рекомендуется не дублировать запросы, а делать с нуля.

   Для начала выбираем окружение Environment_group_28
Создаем запрос: Request_/new_data_for_check_the_variables_name_salary
{{url}}:{{port}}/new_data
POST
Body => form-data:
age 30 
salary 5000
name Valera
auth_token {{token}}

Получим response:
========================
{
    "age": 30,
    "name": "Valera",
    "salary": [
        5000,
        "10000",
        "15000"
    ]
}
========================
27:08


    ДОБАВЛЕНИЕ СТРОК КОДА ДЛЯ ПРОВЕРКИ ЗНАЧЕНИЯ name В ОКНЕ TESTS.
В запросе /new_data в окне Tests вносим сниппеты:
Status code: Code is 200
Response body: JSON value check (тело ответа: проверка значения JSON)

Получаем такой код:
========================
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});


pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.value).to.eql(100);
});
========================

копируем вверх строку, которая парсит json:
========================
var jsonData = pm.response.json();
========================

меням var на let
========================
let jsonData = pm.response.json();
========================
из этой jsonData нам необходимо, что мы проверяем "Your test name"

в части общего кода
========================
pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.value).to.eql(100);
});
========================
вносим изменения, где 
значение jsonData.value меняем на jsonData.name
значение to.eql(100) меняем на to.eql('Valera')

вышеуказанные значения name и Valera для изменений в коде берутся из ответа сервера:
========================
  "age": 30,
    "name": "Valera",
    "salary": [
        5000,
        "10000",
        "15000"
    ]
}
========================

получаем общий код
========================
let jsonData = pm.response.json();


pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.name).to.eql('Valera');
});
========================

теперь, в общий код добавляем строку
========================
let user_name = jsonData.name;
========================

и, в строке кода
========================
pm.expect(jsonData.name).to.eql('Valera');
========================
текст (jsonData.name) меняем на (user_name)

получаем в итоге такой код:
========================
let jsonData = pm.response.json();


pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

let user_name = jsonData.name;
pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(user_name).to.eql('Valera');
});
========================
Сохраняем. Отправляем запрос.

Получаем response:
========================
{
    "age": 30,
    "name": "Valera",
    "salary": [
        5000,
        "10000",
        "15000"
    ]
}
========================

во вкладке Test Results проверяем результаты запроса, где должны получить:
========================
PASS Status code is 200
PASS Your test name
========================
которые говорят о том, что запрос пройден успешно - особое внимание нужно обратить на то, что ответ PASS Your test name говорит о том, что наш код корректно отработал проверку имени пользователя.
28:45


   ДОБАВЛЕНИЕ СТРОК КОДА ДЛЯ ПРОВЕРКИ ЗНАЧЕНИЯ salary, ЧТО ОН РАВЕН 10000, В ОКНЕ TESTS.
В окне Tests копируем часть кода:
========================
let user_name = jsonData.name;
pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(user_name).to.eql('Valera');
});
========================

в этом коде вносим следующие изменения:
========================
let salary_2 = +jsonData.salary[1];
pm.test("Salary after 2 years", function () {
    pm.expect(salary_2).to.eql(10000);
});
========================

вышеуказанные значения salary и 10000 для изменений в коде берутся из ответа сервера:
========================
  "age": 30,
    "name": "Valera",
    "salary": [
        5000,
        "10000",
        "15000"
    ]
}
========================

получаем в итоге такой общий код:
========================
let jsonData = pm.response.json();


pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

let user_name = jsonData.name;
pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    pm.expect(user_name).to.eql('Valera');
});

let salary_2 = +jsonData.salary[1];
pm.test("Salary after 2 years", function () {
    pm.expect(salary_2).to.eql(10000);
});
========================
Сохранить. Отправить запрос.

во вкладке Test Results проверяем результаты запроса, где должны получить:
========================
PASS Status code is 200
PASS Your test name
PASS Salary after 2 years
========================
которые говорят о том, что запрос пройден успешно - особое внимание нужно обратить на то, что ответ PASS Salary after 2 years говорит о том, что наш код корректно отработал проверку зарплаты через два года.
30:23








































